"""
Vulnerability Database for GenTwin
Stores discovered security gaps, attack simulations, and mitigation strategies
"""
import sqlite3
import json
from datetime import datetime
from typing import List, Dict, Optional
import pandas as pd
import numpy as np


class VulnerabilityDB:
    def __init__(self, db_path='gentwin_vulnerabilities.db'):
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        """Initialize database with schema"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Discovered vulnerabilities table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS vulnerabilities (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                vulnerability_type TEXT NOT NULL,
                severity TEXT NOT NULL,
                component TEXT NOT NULL,
                description TEXT NOT NULL,
                impact_score REAL,
                detection_confidence REAL,
                discovered_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                exploitable BOOLEAN DEFAULT 1,
                mitigated BOOLEAN DEFAULT 0
            )
        ''')
        
        # Generated attack scenarios table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS generated_attacks (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                attack_type TEXT NOT NULL,
                target_component TEXT NOT NULL,
                attack_vector JSON NOT NULL,
                success_probability REAL,
                expected_impact TEXT,
                generated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                simulated BOOLEAN DEFAULT 0,
                simulation_result TEXT
            )
        ''')
        
        # Simulation results table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS simulations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                attack_id INTEGER,
                simulation_type TEXT NOT NULL,
                initial_state JSON NOT NULL,
                attack_state JSON NOT NULL,
                final_state JSON NOT NULL,
                process_failure BOOLEAN,
                failure_mode TEXT,
                time_to_failure REAL,
                affected_components TEXT,
                simulated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (attack_id) REFERENCES generated_attacks(id)
            )
        ''')
        
        # Process gaps identified
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS process_gaps (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                gap_type TEXT NOT NULL,
                process_stage TEXT NOT NULL,
                normal_threshold_min REAL,
                normal_threshold_max REAL,
                blind_spot_duration REAL,
                missing_control TEXT,
                recommendation TEXT,
                risk_level TEXT,
                identified_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # Mitigation strategies
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS mitigations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                vulnerability_id INTEGER,
                strategy_name TEXT NOT NULL,
                implementation_complexity TEXT,
                estimated_effectiveness REAL,
                deployment_time TEXT,
                description TEXT,
                status TEXT DEFAULT 'proposed',
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (vulnerability_id) REFERENCES vulnerabilities(id)
            )
        ''')
        
        conn.commit()
        conn.close()
        print("✓ Vulnerability database initialized")
    
    def add_vulnerability(self, vuln_type: str, severity: str, component: str, 
                         description: str, impact_score: float, confidence: float):
        """Add discovered vulnerability"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO vulnerabilities 
            (vulnerability_type, severity, component, description, impact_score, detection_confidence)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (vuln_type, severity, component, description, impact_score, confidence))
        
        vuln_id = cursor.lastrowid
        conn.commit()
        conn.close()
        return vuln_id
    
    def add_generated_attack(self, attack_type: str, target: str, vector: dict, 
                            success_prob: float, impact: str):
        """Store GenAI-generated attack scenario"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO generated_attacks 
            (attack_type, target_component, attack_vector, success_probability, expected_impact)
            VALUES (?, ?, ?, ?, ?)
        ''', (attack_type, target, json.dumps(vector), success_prob, impact))
        
        attack_id = cursor.lastrowid
        conn.commit()
        conn.close()
        return attack_id
    
    def add_simulation_result(self, attack_id: int, sim_type: str, 
                             initial_state: dict, attack_state: dict, final_state: dict,
                             process_failure: bool, failure_mode: str, 
                             time_to_failure: float, affected: str):
        """Store digital twin simulation results"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO simulations 
            (attack_id, simulation_type, initial_state, attack_state, final_state,
             process_failure, failure_mode, time_to_failure, affected_components)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (attack_id, sim_type, 
              json.dumps(initial_state), json.dumps(attack_state), json.dumps(final_state),
              process_failure, failure_mode, time_to_failure, affected))
        
        sim_id = cursor.lastrowid
        
        # Update attack as simulated
        cursor.execute('''
            UPDATE generated_attacks 
            SET simulated = 1, simulation_result = ?
            WHERE id = ?
        ''', (failure_mode, attack_id))
        
        conn.commit()
        conn.close()
        return sim_id
    
    def add_process_gap(self, gap_type: str, stage: str, min_thresh: float, 
                       max_thresh: float, blind_spot: float, missing: str, 
                       recommendation: str, risk: str):
        """Add identified process-level gap"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO process_gaps 
            (gap_type, process_stage, normal_threshold_min, normal_threshold_max,
             blind_spot_duration, missing_control, recommendation, risk_level)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        ''', (gap_type, stage, min_thresh, max_thresh, blind_spot, missing, recommendation, risk))
        
        gap_id = cursor.lastrowid
        conn.commit()
        conn.close()
        return gap_id
    
    def add_mitigation(self, vuln_id: int, strategy: str, complexity: str, 
                      effectiveness: float, time: str, description: str):
        """Add mitigation strategy"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO mitigations 
            (vulnerability_id, strategy_name, implementation_complexity, 
             estimated_effectiveness, deployment_time, description)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (vuln_id, strategy, complexity, effectiveness, time, description))
        
        mit_id = cursor.lastrowid
        conn.commit()
        conn.close()
        return mit_id
    
    def get_vulnerabilities(self, severity: Optional[str] = None, 
                           mitigated: Optional[bool] = None) -> List[Dict]:
        """Retrieve vulnerabilities with optional filters"""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        query = "SELECT * FROM vulnerabilities WHERE 1=1"
        params = []
        
        if severity:
            query += " AND severity = ?"
            params.append(severity)
        
        if mitigated is not None:
            query += " AND mitigated = ?"
            params.append(mitigated)
        
        query += " ORDER BY impact_score DESC, discovered_at DESC"
        
        cursor.execute(query, params)
        results = [dict(row) for row in cursor.fetchall()]
        conn.close()
        return results
    
    def get_process_gaps(self, risk_level: Optional[str] = None) -> List[Dict]:
        """Retrieve process gaps"""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        query = "SELECT * FROM process_gaps WHERE 1=1"
        params = []
        
        if risk_level:
            query += " AND risk_level = ?"
            params.append(risk_level)
        
        query += " ORDER BY identified_at DESC"
        
        cursor.execute(query, params)
        results = [dict(row) for row in cursor.fetchall()]
        conn.close()
        return results
    
    def get_simulation_stats(self) -> Dict:
        """Get simulation statistics"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        stats = {}
        
        # Total simulations
        cursor.execute("SELECT COUNT(*) FROM simulations")
        stats['total_simulations'] = cursor.fetchone()[0]
        
        # Process failures
        cursor.execute("SELECT COUNT(*) FROM simulations WHERE process_failure = 1")
        stats['process_failures'] = cursor.fetchone()[0]
        
        # Average time to failure
        cursor.execute("SELECT AVG(time_to_failure) FROM simulations WHERE process_failure = 1")
        result = cursor.fetchone()[0]
        stats['avg_time_to_failure'] = float(result) if result else 0.0
        
        # Failure modes
        cursor.execute('''
            SELECT failure_mode, COUNT(*) as count 
            FROM simulations 
            WHERE process_failure = 1 
            GROUP BY failure_mode
        ''')
        stats['failure_modes'] = {row[0]: row[1] for row in cursor.fetchall()}
        
        # Most vulnerable components
        cursor.execute('''
            SELECT affected_components, COUNT(*) as count 
            FROM simulations 
            WHERE process_failure = 1 
            GROUP BY affected_components 
            ORDER BY count DESC 
            LIMIT 5
        ''')
        stats['vulnerable_components'] = {row[0]: row[1] for row in cursor.fetchall()}
        
        conn.close()
        return stats
    
    def get_mitigation_summary(self) -> Dict:
        """Get mitigation strategy summary"""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT m.*, v.severity, v.component 
            FROM mitigations m
            JOIN vulnerabilities v ON m.vulnerability_id = v.id
            ORDER BY m.created_at DESC
        ''')
        
        results = [dict(row) for row in cursor.fetchall()]
        conn.close()
        return results
    
    def export_to_csv(self, table: str, filepath: str):
        """Export table to CSV for analysis"""
        conn = sqlite3.connect(self.db_path)
        df = pd.read_sql_query(f"SELECT * FROM {table}", conn)
        df.to_csv(filepath, index=False)
        conn.close()
        print(f"✓ Exported {table} to {filepath}")


# Example usage
if __name__ == "__main__":
    db = VulnerabilityDB()
    
    # Add sample vulnerability
    vuln_id = db.add_vulnerability(
        vuln_type="Threshold Bypass",
        severity="HIGH",
        component="LIT101_Tank_Level",
        description="Tank overflow detection has 12.3s blind spot during pump transitions",
        impact_score=8.5,
        confidence=0.92
    )
    
    # Add process gap
    db.add_process_gap(
        gap_type="Missing Redundancy",
        stage="Chemical Dosing",
        min_thresh=2.1,
        max_thresh=4.8,
        blind_spot=12.3,
        missing="Secondary flow meter",
        recommendation="Install redundant FIT201 with independent controller",
        risk="HIGH"
    )
    
    print("✓ Database test completed")